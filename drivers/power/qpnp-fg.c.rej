--- drivers/power/qpnp-fg.c
+++ drivers/power/qpnp-fg.c
@@ -518,6 +542,13 @@ struct fg_chip {
 	bool			init_done;
 	int			cold_hysteresis;
 	int			hot_hysteresis;
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	struct fg_somc_params	somc_params;
+	u32		battery_soc;
+	u32		cc_soc;
+	u32		soc_system;
+	u32		soc_monotonic;
+#endif
 };
 
 /* FG_MEMIF DEBUGFS structures */
@@ -2332,9 +2547,17 @@ out:
 		if (rc)
 			pr_err("failed to write BATT_TEMP_OFF rc=%d\n", rc);
 	}
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	schedule_delayed_work(
+		&chip->update_temp_work,
+		msecs_to_jiffies(chip->somc_params.period_update_ms ?
+			chip->somc_params.period_update_ms :
+			TEMP_PERIOD_UPDATE_MS));
+#else
 	schedule_delayed_work(
 		&chip->update_temp_work,
 		msecs_to_jiffies(TEMP_PERIOD_UPDATE_MS));
+#endif
 	fg_relax(&chip->update_temp_wakeup_source);
 }
 
@@ -4337,10 +4668,27 @@ static int populate_system_data(struct fg_chip *chip)
 	}
 	chip->nom_cap_uah = bcap_uah_2b(buffer);
 	chip->actual_cap_uah = chip->nom_cap_uah;
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	if (chip->learning_data.learned_cc_uah <= 0 ||
+		chip->learning_data.learned_cc_uah > (chip->nom_cap_uah *
+			LEARNED_CC_RANGE / 10)) {
+#else
 	if (chip->learning_data.learned_cc_uah == 0) {
+#endif
 		chip->learning_data.learned_cc_uah = chip->nom_cap_uah;
 		fg_cap_learning_save_data(chip);
 	}
+
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	if (chip->somc_params.set_cc_soc_coeff) {
+		int16_t cc_mah = div64_s64(chip->nom_cap_uah, 1000);
+		rc = somc_fg_calc_and_store_cc_soc_coeff(chip->dev, cc_mah);
+		if (rc)
+			pr_err("Failed to write cc_soc_coeff");
+		else
+			chip->somc_params.set_cc_soc_coeff = false;
+	}
+#endif
 	rc = fg_mem_read(chip, buffer, CUTOFF_VOLTAGE_REG, 2, 0, 0);
 	if (rc) {
 		pr_err("Failed to read cutoff voltage: %d\n", rc);
@@ -4882,6 +5234,9 @@ wait:
 	} else {
 		pr_info("Battery profile not same, clearing cycle counters\n");
 		clear_cycle_counter(chip);
+#ifdef CONFIG_QPNP_FG_EXTENSION
+		chip->somc_params.set_cc_soc_coeff = true;
+#endif
 	}
 	if (fg_est_dump)
 		dump_sram(&chip->dump_sram);
@@ -4920,12 +5275,16 @@ wait:
 	}
 
 done:
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	chip->first_profile_loaded = true;
+#else
 	if (fg_batt_type)
 		chip->batt_type = fg_batt_type;
 	else
 		chip->batt_type = batt_type_str;
 	chip->first_profile_loaded = true;
 	chip->profile_loaded = true;
+#endif
 	chip->battery_missing = is_battery_missing(chip);
 	update_chg_iterm(chip);
 	update_cc_cv_setpoint(chip);
@@ -5521,6 +5896,9 @@ static void fg_cleanup(struct fg_chip *chip)
 	cancel_work_sync(&chip->gain_comp_work);
 	cancel_work_sync(&chip->init_work);
 	cancel_work_sync(&chip->charge_full_work);
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	somc_fg_unregister(chip->dev);
+#endif
 	power_supply_unregister(&chip->bms_psy);
 	mutex_destroy(&chip->rslow_comp.lock);
 	mutex_destroy(&chip->rw_lock);
@@ -6445,6 +6846,12 @@ static int fg_probe(struct spmi_device *spmi)
 			"qpnp_fg_gain_comp");
 	wakeup_source_init(&chip->capacity_learning_wakeup_source.source,
 			"qpnp_fg_cap_learning");
+#ifdef CONFIG_QPNP_FG_EXTENSION
+	atomic_set(&chip->memif_wakeup_source.enabled, 0);
+	atomic_set(&chip->profile_wakeup_source.enabled, 0);
+	atomic_set(&chip->update_temp_wakeup_source.enabled, 0);
+	atomic_set(&chip->update_sram_wakeup_source.enabled, 0);
+#endif
 	mutex_init(&chip->rw_lock);
 	mutex_init(&chip->cyc_ctr.lock);
 	mutex_init(&chip->learning_data.learning_lock);
